!function(t,e){"object"==typeof exports&&"undefined"!=typeof module?e(exports):"function"==typeof define&&define.amd?define(["exports"],e):e((t="undefined"!=typeof globalThis?globalThis:t||self).zilt={})}(this,(function(t){"use strict";class e extends Error{}var n={iter:o,once:r,chain:i,range:s,ZiltError:e};function o(t){return new f(t)}function r(t){return new f(function*(){yield t}())}function i(...t){return new f(function*(){for(const e of t)for(const t of e)yield t}())}function s(...t){let e=0,n=1/0;2===t.length?[e,n]=t:1===t.length&&(n=t[0]);const r=e<n?1:-1;return o(function*(){for(let t=e;t!==n;t+=r)yield t}())}class f{constructor(t){this.generator=function*(){for(const e of t)yield e}}*[Symbol.iterator](){for(const t of this.generator())yield t}collect(){return[...this]}consume(){for(const t of this);}map(t){const e=this.generator;return o(function*(){let n=0;for(const o of e())yield t(o,n),n+=1}())}filter(t){const e=this.generator;return o(function*(){let n=0;for(const o of e())t(o,n)&&(yield o,n+=1)}())}skip(t){if(t<0)throw new e("Invalid skip parameter");const n=this.generator;return o(function*(){let e=n();for(let n=0;n<t;++n)e.next();for(const t of e)yield t}())}skipWhile(t){const e=this.generator;return o(function*(){let n=e(),o=n.next().value,r=0;for(;t(o,r);)o=n.next().value,r+=1;yield o;for(const t of n)yield t}())}take(t){if(t<0)throw new e("Invalid take parameter");const n=this.generator;return o(function*(){for(const e of n()){if(0===t)break;yield e,t-=1}}())}takeWhile(t){const e=this.generator;return this.generator=function*(){let n=e(),o=n.next().value,r=0;for(;t(o,r);)yield o,o=n.next().value,r+=1},this}reduce(t,n=null){const o=this[Symbol.iterator]();let r=o.next();if(null===n&&r.done)throw new e("Reduce of empty iterator with no initial value");let i=null===n?r.value:t(n,r.value);for(const e of o)i=t(i,e);return i}accumulate(t,n=null){const r=this[Symbol.iterator]();let i=r.next();if(null===n&&i.done)throw new e("Reduce of empty iterator with no initial value");return o(function*(){let e=null===n?i.value:t(n,i.value);yield e;for(const n of r)e=t(e,n),yield e}())}count(t=(()=>!0)){return this.reduce(((e,n)=>t(n)?e+1:e),0)}rate(t){let e=0;return this.reduce(((n,o)=>(e+=1,t(o)?n+1:n)),0)/e}flatten(t){if(t<0||t>10)throw new e("Invalid depth for flatten, allowed range is [0, 10]");return o(function*e(n,o){for(const r of o)Symbol.iterator in Object(r)&&n!==t?yield*e(n+1,r):yield r}(0,this.generator()))}chunks(t){const e=this.generator;return o(function*(){let n=[];for(const o of e())n.push(o),n.length===t&&(yield n,n=[]);0!==n.length&&(yield n)}())}windows(t){if(t<=0)throw new e("Invalid window length");const n=this.generator;return o(function*(){let e=[],o=!1;for(const r of n())e.push(r),e.length===t&&(yield e,o=!0,e=e.slice(1));o||(yield e)}())}enumerate(){const t=this.generator;return o(function*(){let e=0;for(const n of t())yield[n,e],e+=1}())}step(t){if(t<=0)throw new e("Invalid step");const n=this.generator;return o(function*(){let e=0;for(const o of n())e%t==0&&(yield o),e+=1}())}zip(...t){const e=this.generator;return o(function*(){const n=[e(),...t.map((t=>t[Symbol.iterator]()))];let o=n.map((t=>t.next()));for(;o.every((t=>!t.done));){const t=o.map((t=>t.value));yield t,o=n.map((t=>t.next()))}}())}unzip(){let t=[];const n=e=>{const n=t.length;t.length=Math.max(n,e);for(let e=n;e<t.length;e++)t[e]=[]};for(const o of this.generator()){if(!1===Array.isArray(o))throw new e("Element type is not an array");const r=o;n(r.length);let i=0;for(const e of r)t[i].push(e),i+=1}return t}flatMap(t){return this.map(t).flatten(1)}partition(t){const e=[],n=[];let o=0;for(const r of this.generator())t(r,o)?e.push(r):n.push(r),o+=1;return[e,n]}nth(t){if(t>=0){const e=this.skip(t)[Symbol.iterator]().next();if(!e.done)return e.value}}first(){return this.nth(0)}last(){let t;for(const e of this.generator())t=e;return t}every(t){let e=0;for(const n of this.generator()){if(!t(n,e))return!1;e+=1}return!0}some(t){let e=0;for(const n of this.generator()){if(t(n,e))return!0;e+=1}return!1}find(t){let e=0;for(const n of this.generator()){if(t(n,e))return n;e+=1}}position(t){let e=0;for(const n of this.generator()){if(t(n,e))return e;e+=1}}chain(...t){const e=this.generator;return o(function*(){for(const t of e())yield t;for(const e of t)for(const t of e)yield t}())}cycle(t=1/0){if(t<0)throw new e("Invalid count parameter");const n=this.generator,r=[];return o(function*(){if(0!==t){for(const t of n())r.push(t),yield t;for(;--t;)for(const t of r)yield t}}())}stretch(t){if(t<0)throw new e("Invalid stretch parameter");const n=this.generator;return o(function*(){if(0!==t)for(const e of n())for(const n of s(0,t))yield e}())}forEach(t){let e=0;for(const n of this)t(n,e),e+=1}min(t){let e,n=1/0;for(const o of this.generator()){const r=t(o);r<n&&(n=r,e=o)}return e}max(t){let e,n=-1/0;for(const o of this.generator()){const r=t(o);r>n&&(n=r,e=o)}return e}unique(){return this.uniqueBy((t=>t))}uniqueBy(t){const e=this.generator;return o(function*(){const n=new Set;for(const o of e())!1===n.has(t(o))&&(yield o,n.add(t(o)))}())}inspect(t){const e=this.generator;return o(function*(){for(const n of e())t(n),yield n}())}slice(t,n=1/0){if(t<0||n<0||t>n)throw new e("Invalid slice range");return this.skip(t).take(n-t)}nest(t){const e=this.generator,n=[...t];return o(function*(){for(const t of e())for(const e of n)yield[t,e]}())}nestRange(...t){const e=this.generator;let n=0,r=1/0;return 2===t.length?[n,r]=t:1===t.length&&(r=t[0]),o(function*(){for(const t of e())for(const e of s(n,r))yield[t,e]}())}}t.ZiltError=e,t.chain=i,t.default=n,t.iter=o,t.once=r,t.range=s,Object.defineProperty(t,"__esModule",{value:!0})}));
